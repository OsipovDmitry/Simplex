layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include<indirect_commands.glsl>
#include<draw_data.glsl>
#include<drawable.glsl>
#include<material.glsl>
#include<mesh.glsl>
#include<camera.glsl>
#include<scene_info.glsl>
#include<math/classifications.glsl>
#include<math/intersections.glsl>

layout (std430) buffer ssbo_opaqueCommandsBuffer {
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) buffer ssbo_transparentCommandsBuffer {
	DrawArraysIndirectCommand transparentCommands[];
};

void updateNearFar(inout vec2 nearFar, in vec3 v)
{	
	const float z = -v.z;
	nearFar[0u] = min(nearFar[0u], z);
	nearFar[1u] = max(nearFar[1u], z);
}

void main(void)
{
    if (all(lessThan(gl_GlobalInvocationID, uvec3(sceneInfoDrawDataCount(), 1u, 1u))))
    {
		const uint drawDataID = gl_GlobalInvocationID.x;
		const uint drawableID = drawDataDrawableID(drawDataID);
		if (drawableID != 0xFFFFFFFFu)
		{
			const uint meshID = drawableMeshID(drawableID);
			if (meshID != 0xFFFFFFFFu)
			{
				const BoundingBox localBoundingBox = meshBoundingBox(meshID);
				
				if (!isBoundingBoxEmpty(localBoundingBox))
				{
					const Transform modelViewTransform = transformMult(cameraViewTransform(), drawDataTransform(drawDataID));
					const BoundingBox boundingBox = transformBoundingBox(modelViewTransform, localBoundingBox);
					const Frustum frustum = makeFrustum(makeIdentityTransform(), cameraClipSpace(), cameraCullPlaneLimits());
					
					if (frustumClassifyBoundingBox(frustum, boundingBox) != OUTSIDE)
					{	
						vec2 nearFar = vec2(FLT_MAX, 0.0f);
						
						for (uint i = 0u; i < BOUNDING_BOX_EDGES_COUNT; ++i)
						{
							const LineSegment edge = boundingBoxEdge(boundingBox, i);
							const LineSegmentIntersectFrustumResult lsifr = lineSegmentIntersectFrustum(edge, frustum);
							for (uint j = 0u; j < lsifr.count; ++j)
								updateNearFar(nearFar, lsifr.p[j]);
						}
						
						for (uint i = 0u; i < FRUSTUM_EDGES_COUNT; ++i)
						{
							const LineSegment edge = frustumEdge(frustum, i);
							const LineSegmentIntersectBoundingBoxResult lsibbr = lineSegmentIntersectBoundingBox(edge, boundingBox);
							for (uint j = 0u; j < lsibbr.count; ++j)
								updateNearFar(nearFar, lsibbr.p[j]);
						}
						
						cameraExpandZRange(nearFar);

						const uint materialID = drawableMaterialID(drawableID);
						if (materialID != 0xFFFFFFFFu)
						{
							if (isMeshTransparent(meshID) || isMaterialTransparent(materialID))
							{
								const uint commandID = sceneInfoGenerateTransparentCommandID();
								transparentCommands[commandID] = DrawArraysIndirectCommand(
									meshElementsDataSize(meshID),
									1u,
									meshElementsDataOffset(meshID),
									drawDataID);
							}
							else
							{
								const uint commandID = sceneInfoGenerateOpaqueCommandID();
								opaqueCommands[commandID] = DrawArraysIndirectCommand(
									meshElementsDataSize(meshID),
									1u,
									meshElementsDataOffset(meshID),
									drawDataID);
							}
						}
					}
				}
			}
		}
    }
}