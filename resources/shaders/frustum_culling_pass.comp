layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include<indirect_commands.glsl>
#include<draw_data.glsl>
#include<drawable.glsl>
#include<material.glsl>
#include<mesh.glsl>
#include<camera.glsl>
#include<math/bounding_box.glsl>

layout (std430) buffer ssbo_opaqueCommandsBuffer {
	DrawIndirectCommandsBufferReservedData opaqueIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) buffer ssbo_transparentCommandsBuffer {
	DrawIndirectCommandsBufferReservedData transparentIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand transparentCommands[];
};
layout (std430) buffer ssbo_ZRangeBuffer {
	uvec2 ZRange;
};

void main(void)
{
    uint drawDataID = gl_GlobalInvocationID.x;
    if (drawDataID < drawDataCount())
    {
		Transform ddTransform = drawDataTransform(drawDataID);
		Transform ddTransformInverted = transformInverted(ddTransform);
		
		Frustum frustum = cameraFrustum();
		Frustum transformedFrustum = transformFrustum(ddTransformInverted, frustum);
	
		uint drawableID = drawDataDrawableID(drawDataID);
		uint meshID = drawableMeshID(drawableID);
		
		BoundingBox boundingBox = meshBoundingBox(meshID);
		
		bool isVisible = !isBoundingBoxEmpty(boundingBox);
		
		for (uint i = 0u; isVisible && (i < FRUSTUM_PLANES_COUNT); ++i)
		{
			if (boundingBoxDistanceToPlane(boundingBox, transformedFrustum.planes[i]) < 0.0f)
				isVisible = false;
		}
		
		for (uint k = 0u; isVisible && (k < 3u); ++k)
		{
			bool anyInside = false;
			for (uint i = 0u; !anyInside && (i < FRUSTUM_POINTS_COUNT); ++i)
				if (transformedFrustum.points[i][k] >= boundingBox.points[0u][k])
					anyInside = true;
			if (!anyInside)
				isVisible = false;
		}
		
		for (uint k = 0u; isVisible && (k < 3u); ++k)
		{
			bool anyInside = false;
			for (uint i = 0u; !anyInside && (i < FRUSTUM_POINTS_COUNT); ++i)
				if (transformedFrustum.points[i][k] <= boundingBox.points[1u][k])
					anyInside = true;
			if (!anyInside)
				isVisible = false;
		}
		
		if (isVisible)
		{
			vec3 points[BOUNDING_BOX_POINTS_COUNT + FRUSTUM_POINTS_COUNT + BOUNDING_BOX_EDGES_COUNT];
			uint pointsCount = 0u;
			
			for (uint i = 0u; i < BOUNDING_BOX_POINTS_COUNT; ++i)
			{
				const vec3 point = boundingBoxPoint(boundingBox, i);
				if (frustumClassifyPoint(transformedFrustum, point) != -1)
					points[pointsCount++] = point;
			}
			
			for (uint i = 0u; i < FRUSTUM_POINTS_COUNT; ++i)
			{
				const vec3 point = transformedFrustum.points[i];
				if (boundingBoxClassifyPoint(boundingBox, point) != -1)
					points[pointsCount++] = point;
			}
			
			for (uint i = 0u; i < BOUNDING_BOX_EDGES_COUNT; ++i)
			{
				LineSegment edge = boundingBoxEdge(boundingBox, i);
				for (uint j = 0u; j < FRUSTUM_SIDE_PLANES_COUNT; ++j)
				{
					vec3 point;
					if (lineSegmentIntersectPlane(edge, transformedFrustum.planes[j], point))
						points[pointsCount++] = point;
				}
			}
			
			vec2 nearFar = vec2(FLT_MAX, 0.0f);
			const vec4 frustumNearPlane = frustum.planes[4u]; 
			for (uint i = 0u; i < pointsCount; ++i)
			{
				const float distance = distanceToPlane(frustumNearPlane, transformPoint(ddTransform, points[i]));
				if (distance > -EPS)
				{
					nearFar[0u] = min(nearFar[0u], distance);
					nearFar[1u] = max(nearFar[1u], distance);
				}
			}
			nearFar[0u] = max(nearFar[0u], 0.0f);
			
			atomicMin(ZRange[0u], floatBitsToUint(nearFar[0u]));
			atomicMax(ZRange[1u], floatBitsToUint(nearFar[1u])); 
		}
		
		if (isVisible)
		{
			uint materialID = drawableMaterialID(drawableID);
			
			if (isMeshTransparent(meshID) || isMaterialTransparent(materialID))
			{
				uint commandID = atomicAdd(transparentIndirectCommandsBufferReservedData.count, 1u);
				transparentCommands[commandID] = DrawArraysIndirectCommand(
					meshNumElements(meshID),
					1u,
					meshElementsOffset(meshID),
					drawDataID);
			}
			else
			{
				uint commandID = atomicAdd(opaqueIndirectCommandsBufferReservedData.count, 1u);
				opaqueCommands[commandID] = DrawArraysIndirectCommand(
					meshNumElements(meshID),
					1u,
					meshElementsOffset(meshID),
					drawDataID);
			}
		}
    }
}