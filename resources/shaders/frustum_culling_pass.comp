layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include<indirect_commands.glsl>
#include<draw_data.glsl>
#include<drawable.glsl>
#include<material.glsl>
#include<mesh.glsl>
#include<camera.glsl>
#include<scene_info.glsl>
#include<math/classifications.glsl>
#include<math/intersections.glsl>

layout (std430) buffer ssbo_opaqueCommandsBuffer {
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) buffer ssbo_transparentCommandsBuffer {
	DrawArraysIndirectCommand transparentCommands[];
};

void updateNearFar(inout vec2 nearFar, in vec3 v)
{
	const float z = -v.z;
	nearFar[0u] = min(nearFar[0u], z);
	nearFar[1u] = max(nearFar[1u], z);
}

void main(void)
{
    if (all(lessThan(gl_GlobalInvocationID, uvec3(sceneInfoDrawDataCount(), 1u, 1u))))
    {
		const uint drawDataID = gl_GlobalInvocationID.x;
		const uint drawableID = drawDataDrawableID(drawDataID);
		if (drawableID != 0xFFFFFFFFu)
		{
			const Transform modelViewTransform = transformMult(cameraViewTransform(), drawDataTransform(drawDataID));
			const Frustum frustum = makeFrustum(
				modelViewTransform,
				cameraClipSpace(),
				cameraCullPlaneLimits());
			
			uint meshID = drawableMeshID(drawableID);
			BoundingBox boundingBox = meshBoundingBox(meshID);
			
			if (!isBoundingBoxEmpty(boundingBox) && (frustumClassifyBoundingBox(frustum, boundingBox) != OUTSIDE))
			{	
				vec2 nearFar = vec2(FLT_MAX, 0.0f);
				
				for (uint i = 0u; i < BOUNDING_BOX_EDGES_COUNT; ++i)
				{
					const LineSegment edge = boundingBoxEdge(boundingBox, i);
					const LineSegmentIntersectFrustumResult lsifr = lineSegmentIntersectFrustum(edge, frustum);
					for (uint j = 0u; j < lsifr.count; ++j)
						updateNearFar(nearFar, transformPoint(modelViewTransform, lsifr.p[j]));
				}
				
				for (uint i = 0u; i < FRUSTUM_EDGES_COUNT; ++i)
				{
					const LineSegment edge = frustumEdge(frustum, i);
					const LineSegmentIntersectBoundingBoxResult lsibbr = lineSegmentIntersectBoundingBox(edge, boundingBox);
					for (uint j = 0u; j < lsibbr.count; ++j)
						updateNearFar(nearFar, transformPoint(modelViewTransform, lsibbr.p[j]));
				}
				
				cameraExpandZRange(nearFar);

				const uint materialID = drawableMaterialID(drawableID);
				if (isMeshTransparent(meshID) || isMaterialTransparent(materialID))
				{
					const uint commandID = sceneInfoGenerateTransparentCommandID();
					transparentCommands[commandID] = DrawArraysIndirectCommand(
						meshNumElements(meshID),
						1u,
						meshElementsOffset(meshID),
						drawDataID);
				}
				else
				{
					const uint commandID = sceneInfoGenerateOpaqueCommandID();
					opaqueCommands[commandID] = DrawArraysIndirectCommand(
						meshNumElements(meshID),
						1u,
						meshElementsOffset(meshID),
						drawDataID);
				}
			}
		}
    }
}