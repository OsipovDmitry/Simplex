layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include<indirect_commands.glsl>
#include<draw_data.glsl>
#include<drawable.glsl>
#include<material.glsl>
#include<mesh.glsl>
#include<camera.glsl>
#include<scene_info.glsl>
#include<math/classification.glsl>

layout (std430) buffer ssbo_opaqueCommandsBuffer {
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) buffer ssbo_transparentCommandsBuffer {
	DrawArraysIndirectCommand transparentCommands[];
};

void main(void)
{
    uint drawDataID = gl_GlobalInvocationID.x;
    if (drawDataID < sceneInfoDrawDataCount())
    {
		Transform ddTransform = drawDataTransform(drawDataID);
		Transform ddTransformInverted = transformInverted(ddTransform);
		
		Frustum frustum = cameraFrustum();
		Frustum transformedFrustum = transformFrustum(ddTransformInverted, frustum);
	
		uint drawableID = drawDataDrawableID(drawDataID);
		uint meshID = drawableMeshID(drawableID);
		BoundingBox boundingBox = meshBoundingBox(meshID);
		
		if (frustumClassifyBoundingBox(transformedFrustum, boundingBox) != OUTSIDE)
		{
			vec3 points[BOUNDING_BOX_POINTS_COUNT + FRUSTUM_POINTS_COUNT + BOUNDING_BOX_EDGES_COUNT];
			uint pointsCount = 0u;
			
			for (uint i = 0u; i < BOUNDING_BOX_POINTS_COUNT; ++i)
			{
				const vec3 point = boundingBoxPoint(boundingBox, i);
				if (frustumClassifyPoint(transformedFrustum, point) != OUTSIDE)
					points[pointsCount++] = point;
			}
			
			for (uint i = 0u; i < FRUSTUM_POINTS_COUNT; ++i)
			{
				const vec3 point = transformedFrustum.points[i];
				if (boundingBoxClassifyPoint(boundingBox, point) != OUTSIDE)
					points[pointsCount++] = point;
			}
			
			for (uint i = 0u; i < BOUNDING_BOX_EDGES_COUNT; ++i)
			{
				LineSegment edge = boundingBoxEdge(boundingBox, i);
				for (uint j = 0u; j < FRUSTUM_SIDE_PLANES_COUNT; ++j)
				{
					vec3 point;
					if (lineSegmentIntersectPlane(edge, transformedFrustum.planes[j], point))
						points[pointsCount++] = point;
				}
			}
			
			vec2 nearFar = vec2(FLT_MAX, 0.0f);
			const vec4 frustumNearPlane = frustum.planes[4u]; 
			for (uint i = 0u; i < pointsCount; ++i)
			{
				const float distance = distanceToPlane(frustumNearPlane, transformPoint(ddTransform, points[i]));
				if (distance > -EPS)
				{
					nearFar[0u] = min(nearFar[0u], distance);
					nearFar[1u] = max(nearFar[1u], distance);
				}
			}
			nearFar[0u] = max(nearFar[0u], 0.0f);
			sceneInfoExpandZRange(nearFar);

			uint materialID = drawableMaterialID(drawableID);
			if (isMeshTransparent(meshID) || isMaterialTransparent(materialID))
			{
				uint commandID = sceneInfoGenerateTransparentCommandID();
				transparentCommands[commandID] = DrawArraysIndirectCommand(
					meshNumElements(meshID),
					1u,
					meshElementsOffset(meshID),
					drawDataID);
			}
			else
			{
				uint commandID = sceneInfoGenerateOpaqueCommandID();
				opaqueCommands[commandID] = DrawArraysIndirectCommand(
					meshNumElements(meshID),
					1u,
					meshElementsOffset(meshID),
					drawDataID);
			}
		}
    }
}