layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

#include<math/bounding_box.glsl>
#include<camera.glsl>
#include<cluster_node.glsl>

void main(void)
{
	
    if (all(lessThan(gl_GlobalInvocationID, uvec3(cameraClusterTotalSize(), 1u, 1u))))
    {
		const uvec3 clusterSize = cameraClusterSize();
		const uint clusterNodeID = gl_GlobalInvocationID.x;
	
		const uint ID_Z = (clusterNodeID - 0u) / (clusterSize.x * clusterSize.y);
		const uint ID_Y = (clusterNodeID - clusterSize.x * clusterSize.y * ID_Z) / (clusterSize.x);
		const uint ID_X = (clusterNodeID - clusterSize.x * clusterSize.y * ID_Z - clusterSize.x * ID_Y) / (1u);
		
		BoundingBox bb = makeEmptyBoundingBox();
		for (uint i = 0u; i < BOUNDING_BOX_POINTS_COUNT; ++i)
		{
			vec2 NDC_XY = vec2(float(ID_X + bitfieldExtract(i, 0, 1)), float(ID_Y + bitfieldExtract(i, 1, 1)));
			NDC_XY /= vec2(clusterSize.xy);
			NDC_XY *= 2.0f;
			NDC_XY -= vec2(1.0f);

			const vec3 nearPoint = projectPoint(cameraProjectionMatrixInverted(), vec3(NDC_XY, -1.0f));
			const vec3 farPoint = projectPoint(cameraProjectionMatrixInverted(), vec3(NDC_XY, 1.0f));

			const float linearZ = float(ID_Z + bitfieldExtract(i, 2, 1)) / float(clusterSize.z);
			bb = boundingBoxExpand(bb, mix(nearPoint, farPoint, linearZ));
		}

		clusterNodeInitialize(clusterNodeID, bb);
    }
}