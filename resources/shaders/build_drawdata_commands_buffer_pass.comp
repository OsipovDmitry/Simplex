layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include<descriptions.glsl>

layout (std430) readonly buffer ssbo_meshesBuffer { MeshDescription meshes[]; };
layout (std430) readonly buffer ssbo_materialsBuffer { MaterialDescription materials[]; };
layout (std430) readonly buffer ssbo_drawablesBuffer { DrawableDescription drawables[]; };
layout (std430) readonly buffer ssbo_drawDataBuffer {
	DrawDataBufferReservedData drawDataBufferReservedData;
	DrawDataDescription drawData[];
};
layout (std430) buffer ssbo_opaqueCommandsBuffer {
	DrawIndirectCommandsBufferReservedData opaqueIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) buffer ssbo_transparentCommandsBuffer {
	DrawIndirectCommandsBufferReservedData transparenIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand transparentCommands[];
};

void main(void)
{
    uint drawDataID = gl_GlobalInvocationID.x;
    if (drawDataID < drawDataBufferReservedData.count)
    {
		DrawDataDescription drawDataDescription = drawData[drawDataID];
		DrawableDescription drawableDescription = drawables[drawDataDrawableID(drawDataDescription)];
		MeshDescription meshDescription = meshes[drawableDescription.meshID];
		MaterialDescription materialDescription = materials[drawableDescription.materialID];
		
		if (isMeshTransparent(meshDescription) || isMaterialTransparent(materialDescription))
		{
			uint commandID = atomicAdd(transparenIndirectCommandsBufferReservedData.count, 1u);
			transparentCommands[commandID] = DrawArraysIndirectCommand(
				meshNumElements(meshDescription),
				1u,
				meshDescription.elementsOffset,
				drawDataID);
		}
		else
		{
			uint commandID = atomicAdd(opaqueIndirectCommandsBufferReservedData.count, 1u);
			opaqueCommands[commandID] = DrawArraysIndirectCommand(
				meshNumElements(meshDescription),
				1u,
				meshDescription.elementsOffset,
				drawDataID);
		}	
    }
}