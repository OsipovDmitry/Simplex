layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include<descriptions.glsl>

layout (std430) readonly buffer ssbo_meshesBuffer { MeshDescription meshes[]; };
layout (std430) readonly buffer ssbo_materialsBuffer { MaterialDescription materials[]; };
layout (std430) readonly buffer ssbo_drawablesBuffer { DrawableDescription drawables[]; };
layout (std430) readonly buffer ssbo_drawDataBuffer {
	DrawDataBufferReservedData drawDataBufferReservedData;
	DrawDataDescription drawData[];
};
layout (std430) writeonly buffer ssbo_opaqueCommandsBuffer {
	DrawIndirectCommandsBufferReservedData opaqueDrawIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand opaqueCommands[];
};
layout (std430) writeonly buffer ssbo_transparentCommandsBuffer {
	DrawIndirectCommandsBufferReservedData transparenDrawIndirectCommandsBufferReservedData;
	DrawArraysIndirectCommand transparentCommands[];
};

void main(void)
{
    uint drawDataID = gl_GlobalInvocationID.x;
    if (drawDataID < drawDataBufferReservedData.count)
    {
		DrawDataDescription drawDataDescription = drawData[drawDataID];
		DrawableDescription drawableDescription = drawables[drawDataDrawableOffset(drawDataDescription)];
		MeshDescription meshDescription = meshes[drawableDescription.meshOffset];
		MaterialDescription materialDescription = materials[drawableDescription.materialOffset];
		
		if (isMeshTransparent(meshDescription) || isMaterialTransparent(materialDescription))
		{
			uint transparenCommandsID = atomicAdd(transparenDrawIndirectCommandsBufferReservedData.count, 1);
			transparentCommands[transparenCommandsID] = DrawArraysIndirectCommand(
				meshDescription.numElements,
				1u,
				meshDescription.elementsOffset,
				0u);
		}
		else
		{
			uint opaqueCommandsID = atomicAdd(opaqueDrawIndirectCommandsBufferReservedData.count, 1);
			opaqueCommands[opaqueCommandsID] = DrawArraysIndirectCommand(
				meshDescription.numElements,
				1u,
				meshDescription.elementsOffset,
				0u);
		}	
    }
}